/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
    BaseContract,
    BigNumber,
    BigNumberish,
    BytesLike,
    CallOverrides,
    ContractTransaction,
    Overrides,
    PayableOverrides,
    PopulatedTransaction,
    Signer,
    utils,
} from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
    TypedEventFilter,
    TypedEvent,
    TypedListener,
    OnEvent,
    PromiseOrValue,
} from "./common";

export declare namespace RTokenP1 {
    export type IssueItemStruct = {
        when: PromiseOrValue<BigNumberish>;
        amtRToken: PromiseOrValue<BigNumberish>;
        amtBaskets: PromiseOrValue<BigNumberish>;
        deposits: PromiseOrValue<BigNumberish>[];
    };

    export type IssueItemStructOutput = [BigNumber, BigNumber, BigNumber, BigNumber[]] & {
        when: BigNumber;
        amtRToken: BigNumber;
        amtBaskets: BigNumber;
        deposits: BigNumber[];
    };
}

export interface RTokenInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "basketsNeeded()": FunctionFragment;
        "cancel(uint256,bool)": FunctionFragment;
        "claimAndSweepRewards()": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "init(address,string,string,string,uint192,uint192,uint256)": FunctionFragment;
        "issuanceRate()": FunctionFragment;
        "issue(uint256)": FunctionFragment;
        "issueItem(address,uint256)": FunctionFragment;
        "issueQueues(address)": FunctionFragment;
        "main()": FunctionFragment;
        "mandate()": FunctionFragment;
        "maxRedemptionCharge()": FunctionFragment;
        "melt(uint256)": FunctionFragment;
        "mint(address,uint256)": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "proxiableUUID()": FunctionFragment;
        "queueBounds(address)": FunctionFragment;
        "redeem(uint256)": FunctionFragment;
        "redemptionLimit()": FunctionFragment;
        "redemptionRateFloor()": FunctionFragment;
        "redemptionVirtualSupply()": FunctionFragment;
        "scalingRedemptionRate()": FunctionFragment;
        "setBasketsNeeded(uint192)": FunctionFragment;
        "setIssuanceRate(uint192)": FunctionFragment;
        "setRedemptionRateFloor(uint256)": FunctionFragment;
        "setScalingRedemptionRate(uint192)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "upgradeTo(address)": FunctionFragment;
        "upgradeToAndCall(address,bytes)": FunctionFragment;
        "vest(address,uint256)": FunctionFragment;
    };

    getFunction(
        nameOrSignatureOrTopic:
            | "DOMAIN_SEPARATOR"
            | "allowance"
            | "approve"
            | "balanceOf"
            | "basketsNeeded"
            | "cancel"
            | "claimAndSweepRewards"
            | "decimals"
            | "decreaseAllowance"
            | "increaseAllowance"
            | "init"
            | "issuanceRate"
            | "issue"
            | "issueItem"
            | "issueQueues"
            | "main"
            | "mandate"
            | "maxRedemptionCharge"
            | "melt"
            | "mint"
            | "name"
            | "nonces"
            | "permit"
            | "proxiableUUID"
            | "queueBounds"
            | "redeem"
            | "redemptionLimit"
            | "redemptionRateFloor"
            | "redemptionVirtualSupply"
            | "scalingRedemptionRate"
            | "setBasketsNeeded"
            | "setIssuanceRate"
            | "setRedemptionRateFloor"
            | "setScalingRedemptionRate"
            | "symbol"
            | "totalSupply"
            | "transfer"
            | "transferFrom"
            | "upgradeTo"
            | "upgradeToAndCall"
            | "vest"
    ): FunctionFragment;

    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "allowance",
        values: [PromiseOrValue<string>, PromiseOrValue<string>]
    ): string;
    encodeFunctionData(
        functionFragment: "approve",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "basketsNeeded", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "cancel",
        values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
    ): string;
    encodeFunctionData(functionFragment: "claimAndSweepRewards", values?: undefined): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "decreaseAllowance",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(
        functionFragment: "increaseAllowance",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(
        functionFragment: "init",
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ]
    ): string;
    encodeFunctionData(functionFragment: "issuanceRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "issue", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(
        functionFragment: "issueItem",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(functionFragment: "issueQueues", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "main", values?: undefined): string;
    encodeFunctionData(functionFragment: "mandate", values?: undefined): string;
    encodeFunctionData(functionFragment: "maxRedemptionCharge", values?: undefined): string;
    encodeFunctionData(functionFragment: "melt", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(
        functionFragment: "mint",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "permit",
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BytesLike>,
            PromiseOrValue<BytesLike>
        ]
    ): string;
    encodeFunctionData(functionFragment: "proxiableUUID", values?: undefined): string;
    encodeFunctionData(functionFragment: "queueBounds", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "redeem", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "redemptionLimit", values?: undefined): string;
    encodeFunctionData(functionFragment: "redemptionRateFloor", values?: undefined): string;
    encodeFunctionData(functionFragment: "redemptionVirtualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "scalingRedemptionRate", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "setBasketsNeeded",
        values: [PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(
        functionFragment: "setIssuanceRate",
        values: [PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(
        functionFragment: "setRedemptionRateFloor",
        values: [PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(
        functionFragment: "setScalingRedemptionRate",
        values: [PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "transfer",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(
        functionFragment: "transferFrom",
        values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;
    encodeFunctionData(functionFragment: "upgradeTo", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "upgradeToAndCall",
        values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
    ): string;
    encodeFunctionData(
        functionFragment: "vest",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string;

    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "basketsNeeded", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimAndSweepRewards", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "init", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "issuanceRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "issue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "issueItem", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "issueQueues", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "main", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mandate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxRedemptionCharge", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "melt", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proxiableUUID", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queueBounds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "redemptionLimit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "redemptionRateFloor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "redemptionVirtualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "scalingRedemptionRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setBasketsNeeded", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setIssuanceRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setRedemptionRateFloor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setScalingRedemptionRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "upgradeToAndCall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "vest", data: BytesLike): Result;

    events: {
        "AdminChanged(address,address)": EventFragment;
        "Approval(address,address,uint256)": EventFragment;
        "BasketsNeededChanged(uint192,uint192)": EventFragment;
        "BeaconUpgraded(address)": EventFragment;
        "Initialized(uint8)": EventFragment;
        "Issuance(address,uint256,uint192)": EventFragment;
        "IssuanceRateSet(uint192,uint192)": EventFragment;
        "IssuanceStarted(address,uint256,uint256,uint192,address[],uint256[],uint192)": EventFragment;
        "IssuancesCanceled(address,uint256,uint256,uint256)": EventFragment;
        "IssuancesCompleted(address,uint256,uint256,uint256)": EventFragment;
        "Melted(uint256)": EventFragment;
        "Redemption(address,uint256,uint192)": EventFragment;
        "RedemptionRateFloorSet(uint256,uint256)": EventFragment;
        "RewardsClaimed(address,uint256)": EventFragment;
        "ScalingRedemptionRateSet(uint192,uint192)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
        "Upgraded(address)": EventFragment;
    };

    getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "BasketsNeededChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Issuance"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "IssuanceRateSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "IssuanceStarted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "IssuancesCanceled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "IssuancesCompleted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Melted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Redemption"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RedemptionRateFloorSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RewardsClaimed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ScalingRedemptionRateSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
    previousAdmin: string;
    newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<[string, string], AdminChangedEventObject>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface ApprovalEventObject {
    owner: string;
    spender: string;
    value: BigNumber;
}
export type ApprovalEvent = TypedEvent<[string, string, BigNumber], ApprovalEventObject>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface BasketsNeededChangedEventObject {
    oldBasketsNeeded: BigNumber;
    newBasketsNeeded: BigNumber;
}
export type BasketsNeededChangedEvent = TypedEvent<
    [BigNumber, BigNumber],
    BasketsNeededChangedEventObject
>;

export type BasketsNeededChangedEventFilter = TypedEventFilter<BasketsNeededChangedEvent>;

export interface BeaconUpgradedEventObject {
    beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<[string], BeaconUpgradedEventObject>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface InitializedEventObject {
    version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface IssuanceEventObject {
    issuer: string;
    amount: BigNumber;
    baskets: BigNumber;
}
export type IssuanceEvent = TypedEvent<[string, BigNumber, BigNumber], IssuanceEventObject>;

export type IssuanceEventFilter = TypedEventFilter<IssuanceEvent>;

export interface IssuanceRateSetEventObject {
    oldVal: BigNumber;
    newVal: BigNumber;
}
export type IssuanceRateSetEvent = TypedEvent<[BigNumber, BigNumber], IssuanceRateSetEventObject>;

export type IssuanceRateSetEventFilter = TypedEventFilter<IssuanceRateSetEvent>;

export interface IssuanceStartedEventObject {
    issuer: string;
    index: BigNumber;
    amount: BigNumber;
    baskets: BigNumber;
    erc20s: string[];
    quantities: BigNumber[];
    blockAvailableAt: BigNumber;
}
export type IssuanceStartedEvent = TypedEvent<
    [string, BigNumber, BigNumber, BigNumber, string[], BigNumber[], BigNumber],
    IssuanceStartedEventObject
>;

export type IssuanceStartedEventFilter = TypedEventFilter<IssuanceStartedEvent>;

export interface IssuancesCanceledEventObject {
    issuer: string;
    firstId: BigNumber;
    endId: BigNumber;
    amount: BigNumber;
}
export type IssuancesCanceledEvent = TypedEvent<
    [string, BigNumber, BigNumber, BigNumber],
    IssuancesCanceledEventObject
>;

export type IssuancesCanceledEventFilter = TypedEventFilter<IssuancesCanceledEvent>;

export interface IssuancesCompletedEventObject {
    issuer: string;
    firstId: BigNumber;
    endId: BigNumber;
    amount: BigNumber;
}
export type IssuancesCompletedEvent = TypedEvent<
    [string, BigNumber, BigNumber, BigNumber],
    IssuancesCompletedEventObject
>;

export type IssuancesCompletedEventFilter = TypedEventFilter<IssuancesCompletedEvent>;

export interface MeltedEventObject {
    amount: BigNumber;
}
export type MeltedEvent = TypedEvent<[BigNumber], MeltedEventObject>;

export type MeltedEventFilter = TypedEventFilter<MeltedEvent>;

export interface RedemptionEventObject {
    redeemer: string;
    amount: BigNumber;
    baskets: BigNumber;
}
export type RedemptionEvent = TypedEvent<[string, BigNumber, BigNumber], RedemptionEventObject>;

export type RedemptionEventFilter = TypedEventFilter<RedemptionEvent>;

export interface RedemptionRateFloorSetEventObject {
    oldVal: BigNumber;
    newVal: BigNumber;
}
export type RedemptionRateFloorSetEvent = TypedEvent<
    [BigNumber, BigNumber],
    RedemptionRateFloorSetEventObject
>;

export type RedemptionRateFloorSetEventFilter = TypedEventFilter<RedemptionRateFloorSetEvent>;

export interface RewardsClaimedEventObject {
    erc20: string;
    amount: BigNumber;
}
export type RewardsClaimedEvent = TypedEvent<[string, BigNumber], RewardsClaimedEventObject>;

export type RewardsClaimedEventFilter = TypedEventFilter<RewardsClaimedEvent>;

export interface ScalingRedemptionRateSetEventObject {
    oldVal: BigNumber;
    newVal: BigNumber;
}
export type ScalingRedemptionRateSetEvent = TypedEvent<
    [BigNumber, BigNumber],
    ScalingRedemptionRateSetEventObject
>;

export type ScalingRedemptionRateSetEventFilter = TypedEventFilter<ScalingRedemptionRateSetEvent>;

export interface TransferEventObject {
    from: string;
    to: string;
    value: BigNumber;
}
export type TransferEvent = TypedEvent<[string, string, BigNumber], TransferEventObject>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface UpgradedEventObject {
    implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface RToken extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;

    interface: RTokenInterface;

    queryFilter<TEvent extends TypedEvent>(
        event: TypedEventFilter<TEvent>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined
    ): Promise<Array<TEvent>>;

    listeners<TEvent extends TypedEvent>(
        eventFilter?: TypedEventFilter<TEvent>
    ): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;

    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

        allowance(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[BigNumber]>;

        approve(
            spender: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        balanceOf(
            account: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[BigNumber]>;

        basketsNeeded(overrides?: CallOverrides): Promise<[BigNumber]>;

        cancel(
            endId: PromiseOrValue<BigNumberish>,
            earliest: PromiseOrValue<boolean>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        claimAndSweepRewards(
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        decimals(overrides?: CallOverrides): Promise<[number]>;

        decreaseAllowance(
            spender: PromiseOrValue<string>,
            subtractedValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        increaseAllowance(
            spender: PromiseOrValue<string>,
            addedValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        init(
            main_: PromiseOrValue<string>,
            name_: PromiseOrValue<string>,
            symbol_: PromiseOrValue<string>,
            mandate_: PromiseOrValue<string>,
            issuanceRate_: PromiseOrValue<BigNumberish>,
            maxRedemptionCharge_: PromiseOrValue<BigNumberish>,
            redemptionVirtualSupply_: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        issuanceRate(overrides?: CallOverrides): Promise<[BigNumber]>;

        issue(
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        issueItem(
            account: PromiseOrValue<string>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<[RTokenP1.IssueItemStructOutput]>;

        issueQueues(
            arg0: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<
            [BigNumber, BigNumber, BigNumber] & {
                basketNonce: BigNumber;
                left: BigNumber;
                right: BigNumber;
            }
        >;

        main(overrides?: CallOverrides): Promise<[string]>;

        mandate(overrides?: CallOverrides): Promise<[string]>;

        maxRedemptionCharge(overrides?: CallOverrides): Promise<[BigNumber]>;

        melt(
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        mint(
            recipient: PromiseOrValue<string>,
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        name(overrides?: CallOverrides): Promise<[string]>;

        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

        permit(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            value: PromiseOrValue<BigNumberish>,
            deadline: PromiseOrValue<BigNumberish>,
            v: PromiseOrValue<BigNumberish>,
            r: PromiseOrValue<BytesLike>,
            s: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

        queueBounds(
            account: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[BigNumber, BigNumber] & { left: BigNumber; right: BigNumber }>;

        redeem(
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        redemptionLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

        redemptionRateFloor(overrides?: CallOverrides): Promise<[BigNumber]>;

        redemptionVirtualSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

        scalingRedemptionRate(overrides?: CallOverrides): Promise<[BigNumber]>;

        setBasketsNeeded(
            basketsNeeded_: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        setIssuanceRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        setRedemptionRateFloor(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        setScalingRedemptionRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        symbol(overrides?: CallOverrides): Promise<[string]>;

        totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

        transfer(
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        transferFrom(
            from: PromiseOrValue<string>,
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        upgradeTo(
            newImplementation: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        upgradeToAndCall(
            newImplementation: PromiseOrValue<string>,
            data: PromiseOrValue<BytesLike>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;

        vest(
            account: PromiseOrValue<string>,
            endId: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>;
    };

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    allowance(
        owner: PromiseOrValue<string>,
        spender: PromiseOrValue<string>,
        overrides?: CallOverrides
    ): Promise<BigNumber>;

    approve(
        spender: PromiseOrValue<string>,
        amount: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    basketsNeeded(overrides?: CallOverrides): Promise<BigNumber>;

    cancel(
        endId: PromiseOrValue<BigNumberish>,
        earliest: PromiseOrValue<boolean>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimAndSweepRewards(
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    decimals(overrides?: CallOverrides): Promise<number>;

    decreaseAllowance(
        spender: PromiseOrValue<string>,
        subtractedValue: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    increaseAllowance(
        spender: PromiseOrValue<string>,
        addedValue: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    init(
        main_: PromiseOrValue<string>,
        name_: PromiseOrValue<string>,
        symbol_: PromiseOrValue<string>,
        mandate_: PromiseOrValue<string>,
        issuanceRate_: PromiseOrValue<BigNumberish>,
        maxRedemptionCharge_: PromiseOrValue<BigNumberish>,
        redemptionVirtualSupply_: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issuanceRate(overrides?: CallOverrides): Promise<BigNumber>;

    issue(
        amtRToken: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    issueItem(
        account: PromiseOrValue<string>,
        index: PromiseOrValue<BigNumberish>,
        overrides?: CallOverrides
    ): Promise<RTokenP1.IssueItemStructOutput>;

    issueQueues(
        arg0: PromiseOrValue<string>,
        overrides?: CallOverrides
    ): Promise<
        [BigNumber, BigNumber, BigNumber] & {
            basketNonce: BigNumber;
            left: BigNumber;
            right: BigNumber;
        }
    >;

    main(overrides?: CallOverrides): Promise<string>;

    mandate(overrides?: CallOverrides): Promise<string>;

    maxRedemptionCharge(overrides?: CallOverrides): Promise<BigNumber>;

    melt(
        amtRToken: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mint(
        recipient: PromiseOrValue<string>,
        amtRToken: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<string>;

    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    permit(
        owner: PromiseOrValue<string>,
        spender: PromiseOrValue<string>,
        value: PromiseOrValue<BigNumberish>,
        deadline: PromiseOrValue<BigNumberish>,
        v: PromiseOrValue<BigNumberish>,
        r: PromiseOrValue<BytesLike>,
        s: PromiseOrValue<BytesLike>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    queueBounds(
        account: PromiseOrValue<string>,
        overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { left: BigNumber; right: BigNumber }>;

    redeem(
        amount: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    redemptionLimit(overrides?: CallOverrides): Promise<BigNumber>;

    redemptionRateFloor(overrides?: CallOverrides): Promise<BigNumber>;

    redemptionVirtualSupply(overrides?: CallOverrides): Promise<BigNumber>;

    scalingRedemptionRate(overrides?: CallOverrides): Promise<BigNumber>;

    setBasketsNeeded(
        basketsNeeded_: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIssuanceRate(
        val: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRedemptionRateFloor(
        val: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setScalingRedemptionRate(
        val: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
        to: PromiseOrValue<string>,
        amount: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferFrom(
        from: PromiseOrValue<string>,
        to: PromiseOrValue<string>,
        amount: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
        newImplementation: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
        newImplementation: PromiseOrValue<string>,
        data: PromiseOrValue<BytesLike>,
        overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    vest(
        account: PromiseOrValue<string>,
        endId: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

        allowance(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        approve(
            spender: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<boolean>;

        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        basketsNeeded(overrides?: CallOverrides): Promise<BigNumber>;

        cancel(
            endId: PromiseOrValue<BigNumberish>,
            earliest: PromiseOrValue<boolean>,
            overrides?: CallOverrides
        ): Promise<void>;

        claimAndSweepRewards(overrides?: CallOverrides): Promise<void>;

        decimals(overrides?: CallOverrides): Promise<number>;

        decreaseAllowance(
            spender: PromiseOrValue<string>,
            subtractedValue: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<boolean>;

        increaseAllowance(
            spender: PromiseOrValue<string>,
            addedValue: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<boolean>;

        init(
            main_: PromiseOrValue<string>,
            name_: PromiseOrValue<string>,
            symbol_: PromiseOrValue<string>,
            mandate_: PromiseOrValue<string>,
            issuanceRate_: PromiseOrValue<BigNumberish>,
            maxRedemptionCharge_: PromiseOrValue<BigNumberish>,
            redemptionVirtualSupply_: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>;

        issuanceRate(overrides?: CallOverrides): Promise<BigNumber>;

        issue(amtRToken: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

        issueItem(
            account: PromiseOrValue<string>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<RTokenP1.IssueItemStructOutput>;

        issueQueues(
            arg0: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<
            [BigNumber, BigNumber, BigNumber] & {
                basketNonce: BigNumber;
                left: BigNumber;
                right: BigNumber;
            }
        >;

        main(overrides?: CallOverrides): Promise<string>;

        mandate(overrides?: CallOverrides): Promise<string>;

        maxRedemptionCharge(overrides?: CallOverrides): Promise<BigNumber>;

        melt(amtRToken: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

        mint(
            recipient: PromiseOrValue<string>,
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>;

        name(overrides?: CallOverrides): Promise<string>;

        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        permit(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            value: PromiseOrValue<BigNumberish>,
            deadline: PromiseOrValue<BigNumberish>,
            v: PromiseOrValue<BigNumberish>,
            r: PromiseOrValue<BytesLike>,
            s: PromiseOrValue<BytesLike>,
            overrides?: CallOverrides
        ): Promise<void>;

        proxiableUUID(overrides?: CallOverrides): Promise<string>;

        queueBounds(
            account: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[BigNumber, BigNumber] & { left: BigNumber; right: BigNumber }>;

        redeem(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

        redemptionLimit(overrides?: CallOverrides): Promise<BigNumber>;

        redemptionRateFloor(overrides?: CallOverrides): Promise<BigNumber>;

        redemptionVirtualSupply(overrides?: CallOverrides): Promise<BigNumber>;

        scalingRedemptionRate(overrides?: CallOverrides): Promise<BigNumber>;

        setBasketsNeeded(
            basketsNeeded_: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>;

        setIssuanceRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>;

        setRedemptionRateFloor(
            val: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>;

        setScalingRedemptionRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>;

        symbol(overrides?: CallOverrides): Promise<string>;

        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

        transfer(
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<boolean>;

        transferFrom(
            from: PromiseOrValue<string>,
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<boolean>;

        upgradeTo(
            newImplementation: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<void>;

        upgradeToAndCall(
            newImplementation: PromiseOrValue<string>,
            data: PromiseOrValue<BytesLike>,
            overrides?: CallOverrides
        ): Promise<void>;

        vest(
            account: PromiseOrValue<string>,
            endId: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>;
    };

    filters: {
        "AdminChanged(address,address)"(
            previousAdmin?: null,
            newAdmin?: null
        ): AdminChangedEventFilter;
        AdminChanged(previousAdmin?: null, newAdmin?: null): AdminChangedEventFilter;

        "Approval(address,address,uint256)"(
            owner?: PromiseOrValue<string> | null,
            spender?: PromiseOrValue<string> | null,
            value?: null
        ): ApprovalEventFilter;
        Approval(
            owner?: PromiseOrValue<string> | null,
            spender?: PromiseOrValue<string> | null,
            value?: null
        ): ApprovalEventFilter;

        "BasketsNeededChanged(uint192,uint192)"(
            oldBasketsNeeded?: null,
            newBasketsNeeded?: null
        ): BasketsNeededChangedEventFilter;
        BasketsNeededChanged(
            oldBasketsNeeded?: null,
            newBasketsNeeded?: null
        ): BasketsNeededChangedEventFilter;

        "BeaconUpgraded(address)"(
            beacon?: PromiseOrValue<string> | null
        ): BeaconUpgradedEventFilter;
        BeaconUpgraded(beacon?: PromiseOrValue<string> | null): BeaconUpgradedEventFilter;

        "Initialized(uint8)"(version?: null): InitializedEventFilter;
        Initialized(version?: null): InitializedEventFilter;

        "Issuance(address,uint256,uint192)"(
            issuer?: PromiseOrValue<string> | null,
            amount?: PromiseOrValue<BigNumberish> | null,
            baskets?: PromiseOrValue<BigNumberish> | null
        ): IssuanceEventFilter;
        Issuance(
            issuer?: PromiseOrValue<string> | null,
            amount?: PromiseOrValue<BigNumberish> | null,
            baskets?: PromiseOrValue<BigNumberish> | null
        ): IssuanceEventFilter;

        "IssuanceRateSet(uint192,uint192)"(
            oldVal?: PromiseOrValue<BigNumberish> | null,
            newVal?: PromiseOrValue<BigNumberish> | null
        ): IssuanceRateSetEventFilter;
        IssuanceRateSet(
            oldVal?: PromiseOrValue<BigNumberish> | null,
            newVal?: PromiseOrValue<BigNumberish> | null
        ): IssuanceRateSetEventFilter;

        "IssuanceStarted(address,uint256,uint256,uint192,address[],uint256[],uint192)"(
            issuer?: PromiseOrValue<string> | null,
            index?: PromiseOrValue<BigNumberish> | null,
            amount?: PromiseOrValue<BigNumberish> | null,
            baskets?: null,
            erc20s?: null,
            quantities?: null,
            blockAvailableAt?: null
        ): IssuanceStartedEventFilter;
        IssuanceStarted(
            issuer?: PromiseOrValue<string> | null,
            index?: PromiseOrValue<BigNumberish> | null,
            amount?: PromiseOrValue<BigNumberish> | null,
            baskets?: null,
            erc20s?: null,
            quantities?: null,
            blockAvailableAt?: null
        ): IssuanceStartedEventFilter;

        "IssuancesCanceled(address,uint256,uint256,uint256)"(
            issuer?: PromiseOrValue<string> | null,
            firstId?: PromiseOrValue<BigNumberish> | null,
            endId?: PromiseOrValue<BigNumberish> | null,
            amount?: null
        ): IssuancesCanceledEventFilter;
        IssuancesCanceled(
            issuer?: PromiseOrValue<string> | null,
            firstId?: PromiseOrValue<BigNumberish> | null,
            endId?: PromiseOrValue<BigNumberish> | null,
            amount?: null
        ): IssuancesCanceledEventFilter;

        "IssuancesCompleted(address,uint256,uint256,uint256)"(
            issuer?: PromiseOrValue<string> | null,
            firstId?: PromiseOrValue<BigNumberish> | null,
            endId?: PromiseOrValue<BigNumberish> | null,
            amount?: null
        ): IssuancesCompletedEventFilter;
        IssuancesCompleted(
            issuer?: PromiseOrValue<string> | null,
            firstId?: PromiseOrValue<BigNumberish> | null,
            endId?: PromiseOrValue<BigNumberish> | null,
            amount?: null
        ): IssuancesCompletedEventFilter;

        "Melted(uint256)"(amount?: null): MeltedEventFilter;
        Melted(amount?: null): MeltedEventFilter;

        "Redemption(address,uint256,uint192)"(
            redeemer?: PromiseOrValue<string> | null,
            amount?: PromiseOrValue<BigNumberish> | null,
            baskets?: null
        ): RedemptionEventFilter;
        Redemption(
            redeemer?: PromiseOrValue<string> | null,
            amount?: PromiseOrValue<BigNumberish> | null,
            baskets?: null
        ): RedemptionEventFilter;

        "RedemptionRateFloorSet(uint256,uint256)"(
            oldVal?: PromiseOrValue<BigNumberish> | null,
            newVal?: PromiseOrValue<BigNumberish> | null
        ): RedemptionRateFloorSetEventFilter;
        RedemptionRateFloorSet(
            oldVal?: PromiseOrValue<BigNumberish> | null,
            newVal?: PromiseOrValue<BigNumberish> | null
        ): RedemptionRateFloorSetEventFilter;

        "RewardsClaimed(address,uint256)"(
            erc20?: PromiseOrValue<string> | null,
            amount?: PromiseOrValue<BigNumberish> | null
        ): RewardsClaimedEventFilter;
        RewardsClaimed(
            erc20?: PromiseOrValue<string> | null,
            amount?: PromiseOrValue<BigNumberish> | null
        ): RewardsClaimedEventFilter;

        "ScalingRedemptionRateSet(uint192,uint192)"(
            oldVal?: PromiseOrValue<BigNumberish> | null,
            newVal?: PromiseOrValue<BigNumberish> | null
        ): ScalingRedemptionRateSetEventFilter;
        ScalingRedemptionRateSet(
            oldVal?: PromiseOrValue<BigNumberish> | null,
            newVal?: PromiseOrValue<BigNumberish> | null
        ): ScalingRedemptionRateSetEventFilter;

        "Transfer(address,address,uint256)"(
            from?: PromiseOrValue<string> | null,
            to?: PromiseOrValue<string> | null,
            value?: null
        ): TransferEventFilter;
        Transfer(
            from?: PromiseOrValue<string> | null,
            to?: PromiseOrValue<string> | null,
            value?: null
        ): TransferEventFilter;

        "Upgraded(address)"(implementation?: PromiseOrValue<string> | null): UpgradedEventFilter;
        Upgraded(implementation?: PromiseOrValue<string> | null): UpgradedEventFilter;
    };

    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

        allowance(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        approve(
            spender: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        basketsNeeded(overrides?: CallOverrides): Promise<BigNumber>;

        cancel(
            endId: PromiseOrValue<BigNumberish>,
            earliest: PromiseOrValue<boolean>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        claimAndSweepRewards(
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        decimals(overrides?: CallOverrides): Promise<BigNumber>;

        decreaseAllowance(
            spender: PromiseOrValue<string>,
            subtractedValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        increaseAllowance(
            spender: PromiseOrValue<string>,
            addedValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        init(
            main_: PromiseOrValue<string>,
            name_: PromiseOrValue<string>,
            symbol_: PromiseOrValue<string>,
            mandate_: PromiseOrValue<string>,
            issuanceRate_: PromiseOrValue<BigNumberish>,
            maxRedemptionCharge_: PromiseOrValue<BigNumberish>,
            redemptionVirtualSupply_: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        issuanceRate(overrides?: CallOverrides): Promise<BigNumber>;

        issue(
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        issueItem(
            account: PromiseOrValue<string>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        issueQueues(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        main(overrides?: CallOverrides): Promise<BigNumber>;

        mandate(overrides?: CallOverrides): Promise<BigNumber>;

        maxRedemptionCharge(overrides?: CallOverrides): Promise<BigNumber>;

        melt(
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        mint(
            recipient: PromiseOrValue<string>,
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        name(overrides?: CallOverrides): Promise<BigNumber>;

        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        permit(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            value: PromiseOrValue<BigNumberish>,
            deadline: PromiseOrValue<BigNumberish>,
            v: PromiseOrValue<BigNumberish>,
            r: PromiseOrValue<BytesLike>,
            s: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

        queueBounds(
            account: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<BigNumber>;

        redeem(
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        redemptionLimit(overrides?: CallOverrides): Promise<BigNumber>;

        redemptionRateFloor(overrides?: CallOverrides): Promise<BigNumber>;

        redemptionVirtualSupply(overrides?: CallOverrides): Promise<BigNumber>;

        scalingRedemptionRate(overrides?: CallOverrides): Promise<BigNumber>;

        setBasketsNeeded(
            basketsNeeded_: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        setIssuanceRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        setRedemptionRateFloor(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        setScalingRedemptionRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        symbol(overrides?: CallOverrides): Promise<BigNumber>;

        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

        transfer(
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        transferFrom(
            from: PromiseOrValue<string>,
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        upgradeTo(
            newImplementation: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        upgradeToAndCall(
            newImplementation: PromiseOrValue<string>,
            data: PromiseOrValue<BytesLike>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;

        vest(
            account: PromiseOrValue<string>,
            endId: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>;
    };

    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        allowance(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        approve(
            spender: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        balanceOf(
            account: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        basketsNeeded(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        cancel(
            endId: PromiseOrValue<BigNumberish>,
            earliest: PromiseOrValue<boolean>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        claimAndSweepRewards(
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        decreaseAllowance(
            spender: PromiseOrValue<string>,
            subtractedValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        increaseAllowance(
            spender: PromiseOrValue<string>,
            addedValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        init(
            main_: PromiseOrValue<string>,
            name_: PromiseOrValue<string>,
            symbol_: PromiseOrValue<string>,
            mandate_: PromiseOrValue<string>,
            issuanceRate_: PromiseOrValue<BigNumberish>,
            maxRedemptionCharge_: PromiseOrValue<BigNumberish>,
            redemptionVirtualSupply_: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        issuanceRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        issue(
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        issueItem(
            account: PromiseOrValue<string>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        issueQueues(
            arg0: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        main(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        mandate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        maxRedemptionCharge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        melt(
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        mint(
            recipient: PromiseOrValue<string>,
            amtRToken: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        nonces(
            owner: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        permit(
            owner: PromiseOrValue<string>,
            spender: PromiseOrValue<string>,
            value: PromiseOrValue<BigNumberish>,
            deadline: PromiseOrValue<BigNumberish>,
            v: PromiseOrValue<BigNumberish>,
            r: PromiseOrValue<BytesLike>,
            s: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        queueBounds(
            account: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>;

        redeem(
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        redemptionLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        redemptionRateFloor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        redemptionVirtualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        scalingRedemptionRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        setBasketsNeeded(
            basketsNeeded_: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        setIssuanceRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        setRedemptionRateFloor(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        setScalingRedemptionRate(
            val: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        transfer(
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        transferFrom(
            from: PromiseOrValue<string>,
            to: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        upgradeTo(
            newImplementation: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        upgradeToAndCall(
            newImplementation: PromiseOrValue<string>,
            data: PromiseOrValue<BytesLike>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;

        vest(
            account: PromiseOrValue<string>,
            endId: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>;
    };
}
